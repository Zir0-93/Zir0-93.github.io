---
title:  "Clarpse - The Way Source Code Was Meant To Be Analyzed"
date:   2016-07-22 15:04:23
categories: [tech, code, static analysis, uml]
tags: [tech, code, source code analysis, java, parsing]
excerpt_separator: <!--more-->
---
[![Clarity Views Label](http://clarityviews.io/badge)](http://clarityviews.io/github/clarity-team/clarpse?projectName=clarpse) [![Build Status](https://travis-ci.org/Zir0-93/clarpse.svg?branch=master)](https://travis-ci.org/Zir0-93/clarpse) [![codecov](https://codecov.io/gh/Zir0-93/clarpse/branch/master/graph/badge.svg)](https://codecov.io/gh/Zir0-93/clarpse)
<br>
[Clarpse](http://clarityviews.io/github/Zir0-93/clarpse) is a multi-language source code analysis tool designed for extracting deep relationships between entities in a codebase through a clean API. Clarpse makes developer tools like code search and static analyzers better. It supports the development of features like jump to definition, find usages, type inference, and documentation generation.  
 <!--more-->
 
## The Problem

Existing tools for parsing code like the [Eclipse JDT AST Parser](https://github.com/eclipse/eclipse.jdt.core), [JavaParser](http://clarityviews.io/github/javaparser/javaparser) and [Roaster](http://clarityviews.io/github/forge/roaster?projectName=impl) to name a few for Java simply provide information from generated AST's through Node visitors and event listeners. They are great at telling you about properties of an individual source file. However, if your requirements involve understanding components in the context of the entire codebase in order to support complex functionality, you would typically need to develop your own solution. Additionally, because there are no standard cross-language and cross-editor APIs and data formats, it is difficult to reuse your work for more than one programming language.
 
## Let Clarpse Do The Hard Work
Clarpse acts as a layer infront of generated AST's to populage language agnostic source code models with all type and symbol information resolved at parse time. It exposes a clean, easy to use API and outputs data using a well defined, language independant format. All external tools built on top of Clarpse only need to consume this data format in order to support all the languages Clarpse supports! Here are some benefits of using Clarpse:

### Clean Object Oriented API

Clarpse allows developers to analyze the OOP properties of code using a clean, object oriented API.

```java
ClarpseProject project = new ClarpseProject(new ParseRequestContent(new RawFile("file.java",
"package foo.package;
/** Doc Comment */
@Deprecated
public interface Bicycle {
   void changeGear(int newValue);
}"), Lang.JAVA));
 OOPSourceCodeModel model = project.result();
 Component interfaceComponent = model.get("foo.package.Bicycle");
 // retrieve properties of the interface component...
 interfaceComponent.annotations(); // --> {"Deprecated"}
 interfaceComponent.uniqueName();  // --> {"foo.package.Bicycle"}
 interfaceComponent.sourceFile();  // --> {"file.java}
 interfaceComponent.comment();     // --> {" Doc Comment"}
```

### Clarpse is Fast

All type and component information, down to every single method invocation, is resolved at parse time.

```java
final ClarpseProject project = new ClarpseProject(new ParseRequestContent(new RawFile("file",
"package foo.package
import foo.ExternalClass;
import foo.Bicycle;
class ACMEBicycle implements Bicycle {
   void changeGear(int newValue) {
      // simple method call
      ExternalClass.staticMethod(\"yummy cuppy cakes\");
   }
}"), Lang.JAVA));
OOPSourceCodeModel model = project.result();
Component classComponent = model.get("foo.package.ACMEBicycle");
// get the component representing the interface
Component interfaceComponent = model.getComponent{
classComponent.componentInvocations(ComponentInvocations.IMPLEMENTATION).get(0).invokedComponent();
// now we can retrieve more information about the interface
interfaceComponent.uniqueName();
...
// determine which method was invoked in our class
Component methodComponent = model.getComponent(
classComponent.componentInvocations(ComponentInvocations.METHOD).get(0).invokedComponent();
// retrieve more information about this method
methodComponent.uniqueName(); --> "foo.ExternalClass.staticMethod(java.lang.String)
methodComponent.modifiers(); --> ["static", "public"]
```

### Polyglot
No matter what programming language is being parsed (currently support Java), Clarpse will always generate the same object oriented data model that abstracts away any language specific details. Clarpse is designed to be modular and extensible, new languages can be added with little effort.

## Get involved
We are currently fixing bugs and adding support for more languages. Help us out by using Clarpse and sending us feedback, spreading the word, or contributing code! 
